name: Normalize Issue Titles

on:
  workflow_dispatch:

permissions:
  issues: write

jobs:
  normalize-titles:
    runs-on: ubuntu-latest
    steps:
      - name: Normalize GitHub issue titles
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          python - << 'PY'
          import os
          import re
          import sys
          import time
          import json
          from urllib.request import Request, urlopen
          from urllib.parse import urlencode

          GH_TOKEN = os.environ.get("GH_TOKEN")
          REPO = os.environ.get("GITHUB_REPOSITORY")

          if not GH_TOKEN or not REPO:
              print("Missing GH_TOKEN or GITHUB_REPOSITORY", file=sys.stderr)
              sys.exit(1)

          BASE_URL = f"https://api.github.com/repos/{REPO}"

          ECHO_RE = re.compile(r"(ECHO:HKX277206[^\n]*)")
          EIDOLON_RE = re.compile(r"(EIDOLON CODEX[^\n]*)", re.IGNORECASE)

          def log(msg):
              print(msg, flush=True)

          def gh_get(path, params=None):
              if params:
                  qs = "?" + urlencode(params)
              else:
                  qs = ""
              url = BASE_URL + path + qs
              req = Request(url, headers={
                  "Authorization": f"Bearer {GH_TOKEN}",
                  "Accept": "application/vnd.github+json",
                  "X-GitHub-Api-Version": "2022-11-28",
              })
              with urlopen(req) as resp:
                  data = resp.read()
              return json.loads(data.decode("utf-8"))

          def gh_patch(path, payload):
              url = BASE_URL + path
              body = json.dumps(payload).encode("utf-8")
              req = Request(url, data=body, method="PATCH", headers={
                  "Authorization": f"Bearer {GH_TOKEN}",
                  "Accept": "application/vnd.github+json",
                  "X-GitHub-Api-Version": "2022-11-28",
                  "Content-Type": "application/json",
              })
              with urlopen(req) as resp:
                  data = resp.read()
              return json.loads(data.decode("utf-8"))

          def fetch_issues():
              page = 1
              per_page = 100
              while True:
                  issues = gh_get("/issues", {
                      "state": "all",
                      "per_page": per_page,
                      "page": page,
                  })
                  if not issues:
                      break
                  for issue in issues:
                      # skip PRs
                      if "pull_request" in issue:
                          continue
                      yield issue
                  page += 1
                  time.sleep(0.2)

          def compute_new_title(issue):
              current_title = (issue.get("title") or "").strip()
              body = (issue.get("body") or "").strip()
              if not body:
                  return None

              # Prefer explicit ECHO line
              m_echo = ECHO_RE.search(body)
              if m_echo:
                  candidate = m_echo.group(1).strip()
              else:
                  # Then EIDOLON CODEX line
                  m_eid = EIDOLON_RE.search(body)
                  if m_eid:
                      candidate = m_eid.group(1).strip()
                  else:
                      # Fallback: first non-empty line after "Message or Echo"
                      lines = [ln.strip() for ln in body.splitlines()]
                      lines = [ln for ln in lines if ln]
                      if not lines:
                          return None
                      if lines[0].lower().startswith("### message or echo"):
                          lines = lines[1:]
                          lines = [ln for ln in lines if ln]
                          if not lines:
                              return None
                      candidate = re.sub(r"^#+\\s*", "", lines[0]).strip()

              candidate = " ".join(candidate.split())
              if len(candidate) < 5:
                  return None

              if current_title and current_title.lower() not in ("todo", "test", "fix", "echo"):
                  if candidate == current_title:
                      return None

              return candidate

          def main():
              changed = 0
              skipped = 0
              for issue in fetch_issues():
                  number = issue["number"]
                  old_title = (issue.get("title") or "").strip()
                  new_title = compute_new_title(issue)

                  if not new_title:
                      log(f"⏭ Skipping issue #{number} (no suitable derived title).")
                      skipped += 1
                      continue

                  if new_title == old_title:
                      log(f"⏭ Issue #{number} already normalized.")
                      skipped += 1
                      continue

                  log(f"→ Issue #{number}: '{old_title}' → '{new_title}'")
                  try:
                      gh_patch(f"/issues/{number}", {"title": new_title})
                      log(f"✅ Updated issue #{number}")
                      changed += 1
                  except Exception as e:
                      log(f"❌ Failed to update issue #{number}: {e}")
                  time.sleep(0.2)

              log("")
              log(f"Done. Changed: {changed}, skipped: {skipped}")

          if __name__ == "__main__":
              main()
          PY
