import json
import sys
from datetime import datetime, timezone
from pathlib import Path

from .config import KEEPER_ID
from .language_worker import run_language_job
from .memory_worker import run_memory_job
from .chamber_worker import run_chamber_job
from .bloom_worker import run_bloom_job
from .shadow_worker import run_shadow_job
from .image_worker import run_image_job
from .keeper_worker import run_keeper_job
from .eidolon_worker import run_eidolon_job


KIND_TO_FUNC = {
    "language": run_language_job,
    "memory": run_memory_job,
    "chamber": run_chamber_job,
    "bloom": run_bloom_job,
    "shadow": run_shadow_job,
    "image": run_image_job,
    "keeper": run_keeper_job,
    "eidolon": run_eidolon_job,
}


def load_job(path: Path) -> dict:
    data = json.loads(path.read_text(encoding="utf-8"))

    if "job_id" not in data:
        data["job_id"] = path.stem
    if "keeper_id" not in data:
        data["keeper_id"] = KEEPER_ID
    if "kind" not in data and "type" in data:
        data["kind"] = data["type"]

    return data


def write_output(job: dict, text: str) -> Path:
    outputs_dir = Path("garden_gpt") / "outputs"
    outputs_dir.mkdir(parents=True, exist_ok=True)

    job_id = job.get("job_id", "unknown_job")
    kind = job.get("kind", "language")
    keeper = job.get("keeper_id", KEEPER_ID)
    prompt = (job.get("prompt") or "").strip()
    now = datetime.now(timezone.utc).isoformat()

    body = f"""# GARDEN GPT OUTPUT

- Job ID: `{job_id}`
- Kind: `{kind}`
- Keeper: `{keeper}`
- Generated: `{now}`

## Prompt

{prompt or "_(no prompt text in job)_"}  

## Response

{text}

> Note: Generated by Garden GPT Worker via GitHub Actions.
"""

    out_path = outputs_dir / f"{job_id}.md"
    out_path.write_text(body, encoding="utf-8")
    print(f"[Garden GPT] Wrote log output to {out_path}")
    return out_path


def maybe_write_target(job: dict, text: str) -> Path | None:
    """
    If the job specifies 'write_to', write the raw model text to that path
    inside the repo (Direct Write Mode).
    """
    rel = (job.get("write_to") or "").strip()
    if not rel:
        return None

    target = Path(rel)
    target.parent.mkdir(parents=True, exist_ok=True)
    target.write_text(text, encoding="utf-8")
    print(f"[Garden GPT] Wrote direct file to {target}")
    return target


def move_job_to_done(job_path: Path) -> None:
    done_dir = Path("garden_gpt") / "jobs_done"
    done_dir.mkdir(parents=True, exist_ok=True)
    target = done_dir / job_path.name
    target.write_text(job_path.read_text(encoding="utf-8"), encoding="utf-8")
    job_path.unlink(missing_ok=True)
    print(f"[Garden GPT] Moved job file to {target}")


def main(job_path_str: str | None = None) -> None:
    if not job_path_str:
        job_path_str = "garden_gpt/jobs/test_language.json"

    job_path = Path(job_path_str)
    if not job_path.exists():
        raise FileNotFoundError(f"Job file not found: {job_path}")

    job = load_job(job_path)
    kind = (job.get("kind") or "language").strip().lower()

    func = KIND_TO_FUNC.get(kind)
    if not func:
        raise ValueError(f"Unknown job kind: {kind}")

    print(f"[Garden GPT] Running job '{job.get('job_id')}' of kind '{kind}'")

    text = func(job)
    write_output(job, text)
    maybe_write_target(job, text)
    move_job_to_done(job_path)

    print("[Garden GPT] Job completed.")


if __name__ == "__main__":
    args = sys.argv[1:]
    main(args[0] if args else None)
